# What's Explorer?

Explorer是一个实现了锁消除的任务执行器。

# 核心思想

“锁”的存在保证共享资源在同一时间只能被一个线程访问。

任务执行时，可能需要访问多个共享资源，也就需要获取对应的“锁”。如果两个任务访问的资源有交集，需要串行执行，否则允许改变执行顺序，对任务进行重排序。
由此，衍生出“栅栏”的概念，在任务开始和结束时，分别放置一个栅栏，以确保任务执行期间，资源被该任务独享。
我们将“栅栏”具象化为一个`Object`，`Object`能够代表这个资源，任务执行期间`Object`被锁定，每一个任务可以附带多个“栅栏”。

# 快速开始

Explorer的使用非常简单。

首先，创建一个拥有4个线程的Explorer：

```
Explorer explorer = new ReorderedExplorer(4);
```

然后，带上任务的一个或多个`key`提交到线程池即可：

```
explorer.execute(task, "key");
explorer.execute(task, "key1", "key2");
explorer.execute(task, "key1", "key2", "key3");
explorer.execute(task, "keys...");
explorer.execute(task, "playerId", "teamId");
```

最后，在该`keys`下的所有任务，永远是串行执行的。

# 关于设计

### Explorer设计

每个线程仅仅读取指定轨道的Key，如果当前位置为空，则表示没有任务，跳过执行。示意如下：

```
          writeIndex
          |
          +---------------------------+    +---------------------+
QueueA -> | Key1 | Key1 |      | Key1 | -> | Thread-1, readIndex |
          |------+------+------+------|    |---------------------|
QueueB -> |      | Key2 | Key2 |      | -> | Thread-2, readIndex |
          |------+------+------+------|    |---------------------|
QueueC -> | Key3 |      | Key3 |      | -> | Thread-3, readIndex |
          +---------------------------+    +---------------------+
             |      |      |      |
           task3  task1  task2  task0
```

由生产者线程生成任务信息，并将任务发布在事件总线上。任务不再仅仅是单个任务，而是包含执行屏障的任务，屏障可能有一个或多个。
事件总线仅仅维护一个全局的`writerIndex`，每个线程维护自己的`readerIndex`，只要`readerIndex < writerIndex`
则可以继续向下读取，读取到任务后，判断此任务不是这个线程关注的任务，如果是关注任务则执行，否则，跳过执行。

### 拦截器设计

当线程被拦截器拦截后，如果线程处于休眠/自旋等待时，影响吞吐量。大部分时候，期望针对于单Key是串行执行，而不相关的屏障可以重排序执行，也就是越障执行。
它其实很像单行公路上的交警，仅仅拦截某个型号的汽车，让其停靠在路边，而其它型号的汽车则可以提前通过。当收到放行指令后，所有被拦截的汽车优先于正在等待通行的汽车，依次通行。
设计目的：
<ul>
    <li>保证对外表现的一致。</li>
    <li>它不是神丹妙药，但在力所能及的范围内避免死锁。</li>
    <li>降低多线程编码门槛和难度。</li>
    <li>它依然是适用于redis的，但是对于具有唯一ID的，例如：地块ID、公会ID等，有了更好的表现。</li>
</ul>
通过对于仅拦截指定的屏障，而不是全拦截，从而提升吞吐量。线程始终处于运行状态，如图：

```
           +----------------------------------------+     +------------+
QueueA  -> | Key0 Key2 Key4 |      | Key2           | --> |  Thread A  |
           +----------------+ Key2 +----------------+     +------------+
                            |  +   |
           +----------------+ Key3 +----------------+     +------------+
QueueB  -> |           Key1 |      | Key1 Key3 Key5 | --> |  Thread B  |
           +----------------------------------------+     +------------+
```

`Key2 + Key3`是一个共享任务，被两个队列共享，但期望整个任务最终只会被一个线程所执行。假定所有任务执行时长是一样的，任务执行：

线程状态 |               Thread A               |       ThreadB       |
---------|:------------------------------------:|:-------------------:|
第一时刻 |               处理`Key2`               |      处理`Key5`       |
第二时刻 | 遇到共享任务`Key2 + Key3`，生成屏障并跳过，处理`Key4` |      处理`Key3`       |
第三时刻 |      遇到`Key2`，拦截并缓存任务，处理`Key0`       |      处理`Key1`       |
第四时刻 |              进入休眠/自旋/空闲              | 处理共享任务`Key2 + Key3` |
第五时刻 |  释放共享任务屏障`Key2 + Key3`，处理缓存的`Key2`   |      处理`Key1`       |
第六时刻 |                  空闲                  |         空闲          |

拦截器的设计，提升了吞吐量，防止单个任务卡主整个线程。

# 关于性能

### 测试环境

1. OS：Windows 10 专业版
2. CPU：i7-6700K，4核心8线程，4GHz
3. 内存：16G 3800 MHz

### 执行效率

测试一千万空任务执行（Explorer的执行效率）：

1. executor：JDK自带线程池，仅指定线程数量，其它使用默认配置。
2. explorer：测试目标，仅指定线程数量，其它使用默认配置。
3. 8线程CPU，当测试生产者+消费者总数量超过8个时，完全的CPU密集型任务，波动较大。

测试结果如下（单位：毫秒）：

性能对比 | 1生产1消费 | 2生产1消费 | 4生产1消费 |
---------|:------:|:------:|:------:|
executor |  1496  | 1359 | 1431   |
explorer |  930   | 760 | 730    |

性能对比 | 1生产2消费 | 2生产2消费 | 4生产2消费 |
---------|:------:|:------:|:------:|
executor | 2485   | 2074  | 2331   |
explorer | 1120   | 800   | 729   |

性能对比 | 2生产4消费 | 4生产4消费 | 8生产4消费
---------|:------:|:------:|:------:|
executor | 2008   | 2184   | 2115   |
explorer | 1246   | 889   | 1170   |

当线程数量超过cpu核心数量且运算都是CPU密集型运算时，频繁的上下文切换导致测试结果波动较大，随机选取了一组测试结果：

性能对比 | 4生产8消费 | 8生产8消费 | 16生产8消费
---------|:------:|:------:|:------:|
executor | 2160   | 1869   | 1844   |
explorer | 2090   | 1330   | 1270   |

可以看到以下几点：

1. 在单线程环境下，Explorer执行效率已经超过Java自带线程池。
2. 受限于CPU线程数，当任务性价比低并且线程数过多时，吞吐量反而下降。

Explorer设计时考虑如下几点：

1. 特殊的线程模型造成队列的额外的空间消耗。
2. 任务查找造成的额外CPU消耗。
3. 全程无锁设计以提升性能。
4. 降低通用性以提升性能。
5. 充分利用CPU缓存行以提升性能。

### 任务重排序性能

每个障碍包含3个`int`值，测试线程重排序执行（Task Reorder Executor）一千万个任务的性能。

障碍 | 5   | 20   | 50   | 100  |
------|:------:|:------:|:------:|:------:|
时长 | 973 | 1747 | 3728 | 6759 |

4个生产者，2个消费者，每个任务附带两个`int`屏障，测试一千万次，executor执行耗时：2331ms，explorer执行耗时：3779ms。
