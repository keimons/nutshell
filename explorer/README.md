# Explorer使用

Explorer的使用非常简单。

首先，创建一个拥有8个线程的Explorer：

```
Explorer explorer = new ReorderedExplorer(8);
```

然后，带上任务的一个或多个`key`提交到线程池即可：

```
explorer.execute(task, key);
explorer.execute(task, key1, key2);
explorer.execute(task, key1, key2, key3);
explorer.execute(task, keys...);
```

最后，在该`keys`下的所有任务，永远是串行执行的。

# 关于性能

### 测试环境

1. OS：Windows 10 专业版
2. CPU：i7-6700K，4核心8线程，4GHz
3. 内存：16G 3800 MHz

### 执行效率

测试一千万空任务执行（Explorer的执行效率）：

1. executor：JDK自带线程池，仅指定线程数量，其它使用默认配置。
2. explorer：测试目标，仅指定线程数量，其它使用默认配置。
3. executor选取偏好结果，explorer选取偏差结果。
4. 8线程CPU，当测试生产者+消费者总数量超过8个时，波动较大。

测试结果如下（单位：毫秒）：

性能对比 | 1生产1消费 | 2生产1消费 | 4生产1消费 |
---------|------|------|--------|
executor | 1496 | 1359 | 1431   |
explorer | 930 | 760 | 730    |

性能对比 | 1生产2消费 | 2生产2消费 | 4生产2消费 |
---------|--------|-------|--------|
executor | 2485   | 2074  | 2331   |
explorer | 1120   | 800   | 729   |

性能对比 | 2生产4消费 | 4生产4消费 | 8生产4消费
---------|--------|--------|--------|
executor | 2008   | 2184   | 2115   |
explorer | 1246   | 889   | 1170   |

当线程数量超过cpu核心数量且运算都是CPU密集型运算时，频繁的上下文切换导致测试结果波动较大，随机测试结果（Executor选取偏好结果，Explorer选取偏差结果）：

性能对比 | 4生产8消费 | 8生产8消费 | 16生产8消费
---------|--------|--------|--------|
executor | 2160   | 1869   | 1844   |
explorer | 2090   | 1330   | 1270   |

可以看到以下几点：

1. 在单线程环境下，Explorer执行效率已经超过Java自带线程池。
2. 受限于CPU线程数，当任务性价比低并且线程数过多时，吞吐量反而下降。

Explorer设计时考虑如下几点：

1. 特殊的线程模型造成队列的额外的空间消耗。
2. 任务查找造成的额外CPU消耗。
3. 全程无锁设计以提升性能。
4. 降低通用性以提升性能。
5. 充分利用CPU缓存行以提升性能。

### 任务重排序性能

每个障碍包含3个`int`值，测试线程重排序执行（Task Reorder Executor）一千万个任务的性能。

障碍 | 0    | 5   | 20   | 50   | 100  |
------|------|-----|------|------|------|
时长  | 746 | 869 | 1580 | 3259 | 5790 |
