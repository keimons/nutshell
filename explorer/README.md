# Explorer使用

Explorer的使用非常简单。

首先，创建一个拥有8个线程的Explorer：

```
Explorer explorer = new ReorderedExplorer(8);
```

然后，带上任务的一个或多个`key`提交到线程池即可：

```
explorer.execute(task, key);
explorer.execute(task, key1, key2);
explorer.execute(task, key1, key2, key3);
explorer.execute(task, keys...);
```

最后，在该`keys`下的所有任务，永远是串行执行的。

# 性能对比

测试环境：

1. OS：Windows 10 专业版
2. CPU：i7-6700K，4核心8线程，4GHz
3. 内存：16G 3800 MHz

### 执行效率

测试一千万空任务执行（Explorer的执行效率），测试结果如下（单位：毫秒）：

性能对比 | 1生产1消费 | 2生产1消费 | 4生产1消费 |
---------|------|------|------|
executor | 1755 | 1529 | 1372 |
explorer | 1256 | 1098 | 1148 |

性能对比 | 1生产2消费 | 2生产2消费 | 4生产2消费 |
---------|--------|--------|--------|
executor | 2533   | 2483   | 1372   |
explorer | 2619   | 1399   | 1148   |

性能对比 | 2生产4消费 | 4生产4消费 | 8生产4消费
---------|--------|--------|--------|
executor | 1698   | 2296   | 2001   |
explorer | 1842   | 1668   | 1642   |

性能对比 | 4生产8消费 | 8生产8消费 | 16生产8消费
---------|--------|--------|--------|
executor | 2289   | 2256   | 2307   |
explorer | 3226   | 2162   | 2060   |

可以看到以下几点：

1. 在单线程环境下，Explorer执行效率已经明显超过Java自带线程池。
2. 受限于CPU线程数，当任务性价比低并且线程数过多时，吞吐量反而下降。

Explorer设计时考虑如下几点：

1. 特殊的线程模型造成队列的额外的空间消耗。
2. 任务查找造成的额外CPU消耗。
3. 全程无锁设计以提升性能。
4. 降低通用性以提升性能。
5. 充分利用CPU缓存行以提升性能。

## 自窃性能

每个障碍包含3个`int`值，测试线程自窃取（Task Self-Steal）一千万个任务的性能。

count | 0    | 5    | 20   | 50   | 100  |
------|------|------|------|------|------|
time  | 1317 | 1557 | 2338 | 3899 | 6935 |